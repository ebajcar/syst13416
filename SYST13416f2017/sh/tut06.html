<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>Tutorial Set 6</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> 

 	<link rel="stylesheet" type="text/css" href="../css/icons.css" />   
    <link type="text/css" rel="Stylesheet" href="tutorials.css"/>
	<link type="text/css" rel="Stylesheet" href="styles/shCoreDefault.css"/>
	<link type="text/css" rel="Stylesheet" href="styles/shThemeDefault.css"/>	
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushJScript.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	<script type="text/javascript" src="scripts/shBrushCss.js"></script>
	<script type="text/javascript" src="scripts/shBrushBash.js"></script>
	<script type="text/javascript">SyntaxHighlighter.all();</script>

	<style type="text/css">
    :invalid { 
          border-color: #e88;
          -webkit-box-shadow: 0 0 5px rgba(255, 0, 0, .8);
          -moz-box-shadow: 0 0 5px rbba(255, 0, 0, .8);
          -o-box-shadow: 0 0 5px rbba(255, 0, 0, .8);
          -ms-box-shadow: 0 0 5px rbba(255, 0, 0, .8);
          box-shadow:0 0 5px rgba(255, 0, 0, .8);
	</style>	
</head>

<body>
<section class="container">

<!-- 6-1 -->
	<h1>Tutorial Set 6</h1>
	<p class="dent"><strong>In this tutorial...</strong></p>
	<ul>
		<li><a href="#e01">Exercise 1: Programming with bash Shell</a></li>
		<li><a href="#e02">Exercise 2: Working With Variables</a></li>
		<li><a href="#e03">Exercise 3: Explore Environment Variables</a></li>
		<li><a href="#e04">Exercise 4: Personalize your prompt</a></li>
		<li><a href="#e05">Exercise 5: Working with Quotes</a></li>
		<li><a href="#e06">Exercise 6: Operators</a></li>
		<li><a href="#e07">Exercise 7: Conditional statements and test Command </a></li>
		<li><a href="#e08">Exercise 8: Using expr Command to evaluate  </a></li>
		<li><a href="#e09">Exercise 9:  Shell Variables - positional parameters (Command-line Arguments) </a></li>
	</ul>	
	
	<p>&nbsp;</p>
	<p>&nbsp;</p>
	<section id="e01"><h2>Exercise 1: Programming with bash Shell</h2>
	<p>Shell scripts are programs written as plain ASCII text files, using the syntax and semantics of the appropriate shell. There are syntax differences among the shell families, therefore it is important to specify and use a particular shell set of rules. Scripts are executed like other programs, but are not compiled. Each shell has its own interpreter that understands the particular shell language. Generally, shell families share the same syntax and semantics. The following example script demonstrated the use of sha-bang, prologue, and use of comments:</p> 
	<pre class="brush: bash; highlight: [1,2,3,4,5,6,7,8,9];" title=" The sha-bang line, prologue, and inline documentation">
#!/bin/sh
# Program name: myVeryFirst.sh
# Author name: Put your name here
# Date created: Date the file was first created
# Date updated: Date the file was last modified
# Description: 
#	A short description of what the purpose of 	
#	the program is. This script print a couple 
#	of strings to the terminal window.
echo “Hello, you have successfully run your first script.”
echo “Congratulations!”</pre>
	</p>
	
	<p>&nbsp;</p>
	<p>&nbsp;</p>
	<h3>Start off with a SHA-BANG (#!)</h3>
	<p>The sha-bang at the head of a script tells your system that this file contains set of commands to be fed to the command interpreter. Immediately following it, is an absolute path name where the program that interprets the commands in your script resides.
	<pre class="brush: bash; first-line: 1" title="sha-bang line specifies which interpreter is to be used to run this file">#!/bin/bash</pre>
	Document your code using inline comments, even when your code is short.
	<pre class="brush: bash; first-line: 42" title="Comments"># this is a comment on line 42 of the code</pre>
		
	Once you’ve finished entering the content, save the file and exit vi. You can test running your script:
	<p class="highlight-4">
		~$ bash ./myFirstScript.sh
	</p>

	If the script executed without a problem, you can change the permissions appropriately and you are ready to give it to another person to use. 
	<p class="highlight-4">
		~$ chmod 751 myFirstScript.sh
	</p>

	Otherwise, go back and check that you have entered everything properly. Once you make the file executable, you can run it like other commands:
	<p class="highlight-4">
		~$ myFirstScript.sh
	</p>

	Or if the directory is not in the PATH variable:
	<p class="highlight-4">
		~$ ./myFirstScript.sh
	</p>
	<p>
		The development process using shell scripts is the same as for any other programming language! Before you start designing a solution, make sure you understand the problem - a process called <strong>analysing</strong>.
	</p>	
	<p>
		The purpose of programming exercises and assignments, regardless of the language, is to learn:
	</p>
		<ul>
			<li>how to correctly formulate algorithms to solve specific problems - a process called <strong>designing</strong></li>
			<li>how to write those algorithms as programs in the given programming language - a process called <strong>coding</strong> (or sometimes <strong>constructing</strong>)</li>
			<li>how to test a program to provide convincing evidence that it solves the right problem correctly - a process called <strong>testing</strong></li>
			<li>how to provide a clear, concise explanation of the problem that the program is intended to solve, and how it workds - a process called <strong>documenting</strong></li>
		</ul>
	<p>&nbsp;</p>
	<section class="highlight-3">
	<h3>A Guideline for Implementing Good Solutions</h3>
	<p>
		A program can compile (be interpreted) correctly, produce the correct output, and still have major problems. Here are some guidelines for the categories: 1) algorithm design, 2) program style, and 3) program correctness.
	</p>
	<p>
		<strong>Algorithm Design.</strong> is a measure of how well the algorithm has been designed. For example, if the solution calls for a recursive algorithm to be implemented, it is considered to be poorly designed if iterative structures are used. Another example: if the algorithm contains a divide-by-zero instruction, has it been safeguarded against divide-by-zero errors? Consider the following questions:
	</p>
		<ul>
			<li>Has the program been designed using the appropriate programming structures?</li>
			<li>Is the program designed to work correctly for all input cases? What about error cases?</li>
			<li>Is the program designed to give appropriate error messages for bad input data?</li>
		</ul>
	<p>
		<strong>Program Style.</strong> Style consists of comments, mnemonic variable names, and indentation. Thee purpose of good style is to make the meaning of your program clear to someone who has never seen it before, cannot run it, and cannot talk to you. Consider the following questions:</strong> 
	</p>
		<ul>
			<li>Are variable names well chosen?</li>
			<li>Are functions used to partition the program appropriately?</li>
			<li>Is there a clear distinction between variables and constants?</li>
			<li>Is the program flow of control organized rather than just one big lump?</li>
			<li>Are comments relevant rather than simple repetitions of the code?</li>
			<li>Do comments point out key sections of code, indicate special cases, or do they make assertions?</li>			
		</ul>	
	<p class="dent">
		 <strong>Comments.</strong> Use the appropriate comments for the language used. There should be a prologue (or <q>header</q>) specifying at minimum the program name, author(s), date created, date updated, and a short description.  Optionally, it may contain algorithm analysis (input, output), algorithm design (pseudocode) outlining the approach used by the program to solve the problem, and known bugs (if the program does not function correctly in some situations, describe the situations and problems).
	</p>
	<p class="dent">
		<strong>Variable Names.</strong> Each variable name should indicate its meaning. Counters can be named i,j,k and a character can be named simply c, but constructs that are specific to the particular program should have specific, mnemonic names. Good examples: relativeError, speed, sum, temperature, windChill.
	</p>
	<p class="dent">
		<strong>Readability and Indentation.</strong> Indentation should indicate the flow of control. Statements that are nested within a control statement, if, for, while, etc., should be indented a constant distance of at least four (4) spaces.  More deeply nested statements should be more deeply indented. The opening brace delimiting a compound statement should be on a line by itself following the control statement, and closing brace shold be on a line by itself. The indentation of the braces should match the contolling statement, such as in the case of the for statement or the if statement. For alternative acceptable styles, consult the conventions used for your current environment). In case of shell scripts, observe the same rules as the braces.
	</p>
	<p>
		<strong>Program Correctness.</strong> consists of 1) ability to compile/interpret, 2) correct result. Consider the following:
	</p>	
		<ul>
			<li>Does the program compile without any syntax errors or warnings?</li>
			<li>Does the program work correctly for all input (both correct and erroneous)?</li>
			<li>Does the program contain logic errors?</li>
		</ul>		
	<p class="dent">
		<strong>Ability to Compile.</strong> The program should compile/interpret without any warnings or errors. Make sure you use the appropriate syntax when compiling/interpreting your program. The permissions on the script file should be set properly.
	</p>
	<p class="dent">
		<strong>Correct Results.</strong> The program should be evaluated on whether it does exactly what the problem stipulates, not on efficiency or appropriateness of the code. Note that <q>exactly</q> implies that, if the desired output format has been specified explicitly, no deviation from that format is allowed. For example, if two numbers are to be printed on the same line, it would be an error if they are printed on two lines, no matter how certain you are that it would be better that way. Also consider:
	</p>	
		<ul>
			<li>Does the program contain any logic errors? (infinite loops, mathematical errors,...)</li>
			<li>Is the output self-explanatory and well formatted?</li>
		</ul>	
		
	</section>	
	
	
	<p>&nbsp;</p>
	<p>&nbsp;</p>
	<h2 id="e02">Exercise 2: Working With Variables&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
	<p>To assign a value to a variable, choose a name for your variable. 
	<mark>Remember that the Linux namespace is case-sensitive.</mark> 
	Use upper and lower letters, numbers (some symbols are safe to use). 
	Generally, variable names begin with a letter but can contain numerals and the underscore. Avoid using keywords (Keep in mind: if you call your variable cat, it may prevent you from using the command cat). </p>
	<p>	Shell variables are not typed: You do not need to declare variable type; all values are treated as strings by default. Use double quotes to treat spaces and other symbols as part of the string value.</p>
	
	<p>To create local variables at the command prompt, use variable assignment in the form of<br>
	variable=value</p>
	<pre class="brush: bash;"title="NOTE: there is no whitespace around the symbol = ">
	DOG="Barky"
	PI=3.14159
	CAT="Spot"</pre>
	
	<p>	All shell variables are initialized to null strings by default.  This means we do not need to declare variables like in Java.</p>
	
	<pre class="brush: bash; first-line: 4;" title="• Explicit assignment of null strings is possible with:">
	x=" "
	x=' '
	x=	</pre>
	<p>
	<pre class="brush: bash; first-line: 7;" title="• To display variable names and assigned values:">
	echo “That DOG is called $DOG”
	echo “The value of PI is $PI”
	echo “My cat’s name is $CAT”</pre>
	</p>
	<p><pre class="brush: bash;  first-line: 10; highlight: [1];" title="To delete or unset the variable, use the unset command">unset DOG</pre>
	</p>
	<p><pre class="brush: bash;  first-line: 11; highlight: [1];" title="• You can also set a variable to read only">readonly DOG</pre>
	</p>
	<ol><strong>Try the following:</strong>
	<li>At the prompt, create some variables, assigning different values, and display the assigned values.</li>
	
	<li>Create the following variables and assign the corresponding values: x = 7, y = 13. Give the command to display the following<br>The value of x is 7 and the value of y is 13.</li>
	
	<li>Note the results after giving each of the following command.
	<pre class="brush: bash;">
	z=x+y; echo "z equals $z"
	z=$x+$y; echo  "z equals $z"</pre>
	</li>
	
	<li>Why are you getting those results? How would you fix the above commands to display the value 20 (result of actual addition)?</li>
	<li>Check out Chapter 8 of Mark Sobell's book "A Practical Guide..."</li>
	</ol>


<p>&nbsp;</p>
<p>&nbsp;</p>
<!-- 6-2 -->
<h2 id="e03">Exercise 3: Explore Environment Variables&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
	<p>Environment variables are used to provide information to the program you use. Global environment variables are set by your login shell and other programs. Local shell variables are used only by the current shell session and are not passed on to other programs. 
	<pre class="brush: bash; highlight: [1,2];" title=" To list environment variables, use either">
	env
	printenv</pre>
	</p>
	<p>To view the environment variables, use the echo command followed by the name of the variable preceded by the $ symbol. For example:
		<pre class="brush: bash; first-line: 3" title="View the TERM variable, use">echo $TERM</pre>
		<pre class="brush: bash; first-line: 4" title="View your login shell variable SHELL:">echo $SHELL</pre>
		<pre class="brush: bash; first-line: 5" title="View your login shell variable PATH:">echo $PATH</pre>	
		<pre class="brush: bash; first-line: 6" title="Add a directory to the PATH and make it global:">export PATH=$PATH:/new/dir</pre>	
	Note there are no spaces around the equal sign and no spaces in the value being assigned. 
	Also note, this assignment will be effective only for the duration of the session even though it is global. 
	Later you will be including these in a script to make it available on every login.
		
	</p>

	<ol start="5"><strong>Try the following:</strong>
		<li>Include the current directory in your PATH variable (note this may already be included)
		<pre class="brush: bash;">export PATH=$PATH:.</pre>	</li>
		<li>Add your home directory to the PATH variable (note this most likely is already included)
		<pre class="brush: bash;">export PATH=$PATH:$HOME</pre>	</li>	
		<li>Write the command to view the valued assigned to the environment variable HOME.</li>	
		<li>Write the command to add the subdirectory bin in your home directory in your PATH.</li>
		<li>Check out Chapter 8 of Mark Sobell's book "A Practical Guide..."</li>
	</ol>		
<p>&nbsp;</p>

	
	
	<p>&nbsp;</p>
	<p>&nbsp;</p>
<!-- 6-3 -->
<h2 id="e04">Exercise 4:  Personalize your prompt&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
	<p>  Before you begin, save your current prompt in another environment variable:
	<pre class="brush: bash; highlight: [1,2];" title=" To list environment variables, use either">
MYPROMPT=$PS1
echo $MYPROMPT	</pre>
It will return with a string such as:
<pre class="brush: bash; first-line: 3">[\u@\h \W]\$</pre>
	</p>
	<p>When you change the prompt now, you can always get our original prompt back with the 
		command PS1=$MYPROMPT. You will, of course, also get it back when you reconnect, as long  as you
		just fiddle with the prompt on the command line and avoid putting it in a shell configuration file.
		To understand these prompts and the escape sequences used, refer to the Bash info or man pages.	
	<pre class="brush: bash; first-line: 2" title="Issue the commands and note the results: ">
PS1="->"
echo $PS1</pre>
		<pre class="brush: bash; first-line: 3" title="Display time of day and number of running jobs">export PS1="[\t \j] "</pre>
		<pre class="brush: bash; first-line: 4" 
			title="Display date, user name, host name and current working directory. Note that \W displays only base names of the present working directory.">
			export PS1="[\d][\u@\h \w] : "</pre>	
		<pre class="brush: bash; first-line: 5" title=" Display history number for each command.">export PS1="{\!} "</pre>	
		<pre class="brush: bash; first-line: 6" title="Display user@host in pink. ">export PS1="\[\033[1;35m\]\u@\h\[\033[0m\] " </pre>	
		<pre class="brush: bash; first-line: 7" title="Sets the user name in pink and the present working directory in blue.">
PS1="\[\033[1;35m\]\u\[\033[0m\] \[\033[1;34m\]\w\[\033[0m\] "
export PS1</pre>
	
<pre class="brush: bash; first-line: 8" title="Prompt for people who have difficulties seeing the difference between the prompt and what they type. ">export PS1="\[\033[1;44m\]$USER is in \w\[\033[0m\] "
 </pre>		
	</p>
	
<ol start="5"><strong>Try the following:</strong>
	<li>Customize your prompt your way. Experiment. Remember if you get into trouble, you can just close the session and login anew.</li>
	<li>Check out Chapter 8 of Mark Sobell's book "A Practical Guide..."</li>
	<li>You can find more information on ANSI Color Sequences in Wicked Cool Shell Scripts: 101 Scripts for Linux, Mac OS X, and Unix Systems, by Dave Taylor (available on Books 24x7)</li>
</ol>	


	
	
	<p>&nbsp;</p>
	<p>&nbsp;</p>
<h2 id="e05">Exercise 5: Working with Quotes&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
	<p>For each of the following commands, describe the output and explain what the command does. 
	If you are getting an error, debug and note the corrections.</p> 
	<pre class="brush: bash; highlight: [1];" title="">
echo “The average pay is $1000”
echo The average pay is \$1000
echo ‘The average pay is $1000’
echo “The PATH is $PATH. The current directory is `pwd`”
mydir=`pwd`; echo $mydir
size=`wc –c < foo.txt`; echo $size
message=You\ didn’t\ enter\ the\ filename.; echo $message
dirListing=`ls -l`
echo $dirListing     # unquoted
echo "$dirListing"   # quoted
</pre>
<p>Compare the results of lines 1, 2, and 3. What is happening here?</p>
<p>Compare the results of lines 9 and 10. Note • Using echo to output an unquoted variable set with command substitution removes trailing newlines characters from the output of the reassigned command.
</p>


	<p>&nbsp;</p>
	<p>&nbsp;</p>
	<h2 id="e06">Exercise 6: Operators&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
	<section class="highlight-3">
	<p>An operator is a type of function, just like in mathematics. An operator name or operator symbol is a notation which denotes a particular operator. Examples of operators are 
	</p>
	<ul><li>defining operators (assignment), </li>
		<li>evaluating operators (math, conditional statements), and </li>
		<li>redirecting and piping operators.</li>
	</ul>
	</section>
	<h3>Arithmetic Evaluation</h3>
	<p>The shell allows arithmetic expressions to be evaluated, under certain circumstances (see the let and declare built-in commands and Arithmetic Expansion). Evaluation is done in fixed-width integers with no check for overflow, though division by 0 is trapped and flagged as an error. The operators and their precedence, associativity, and values are the same as in the C language. 
	</p>
	
	<h3>Declare Command</h3>
<p>Declare variables and/or give them attributes. If no names are given then display the values of variables. The -p option will display the attributes and values of each name.
</p>
<ul>
	<li>-a&nbsp;&nbsp;&nbsp;Each name is an indexed array variable (see Arrays).</li> 
	<li>-A&nbsp;&nbsp;&nbsp;Each name is an associative array variable (see Arrays).</li>
	<li>-i&nbsp;&nbsp;&nbsp;The variable is treated as an integer; arithmetic evaluation is 	
	performed  when the variable is assigned a value.</li>
	<li>Syntax:<br>
	<code class="syntx">declare [-aAfFilrtux] [-p] [name[=value] ...]</code>
	</li>
</ul>
	<h3>Let Command</h3>
<ul>
	<li>Syntax:<br>
	<code class="syntx">let arg [arg ...]</code>
	</li>

	<li>Each arg is an arithmetic expression to evaluate. If the last arg evaluates to 0, let returns 1; 0 is returned otherwise.	
	</li>
</ul>	
	
	<h3>Arithmetic Expansion</h3>
<ul>
	<li>Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result. The format for arithmetic expansion is:
    <br><code class="syntx">$((expression))</code> 
</li>
<li>The expression is treated as if it were within double quotes, but a double quote inside the parentheses is not treated specially. All tokens in the expression undergo parameter expansion, string expansion, command substitution, and quote removal. Arithmetic expansions may be nested.
	</li>
</ul>	
	
<ol start="8"><strong>Try the following:</strong>
	<li>At the prompt, display content of each variable. Are they the same? Why? Why not?
<pre class="brush: bash; first-line: 1; highlight: [0];" title="">
let x=14+5+4*8; echo $x
let y=(14+5)+4*8; echo $y
let z=(14+5+4)*8; echo $z
</pre>	
	</li>
	<li>Create the following script. What happens if you don’t use the let command?
<pre class="brush: bash; first-line: 1; highlight: [0];" title="">
#!/bin/sh
#Program name: add.sh
#Description: 
#  add 2 numbers and display each number and their sum
let A=1
let B=2
let sum=$A+$B 
echo "A=$A, B=$B, sum=$sum"
</pre>	
	</li>
</ol>	
	

	<p>&nbsp;</p>
	<p>&nbsp;</p>
	<h2 id="e07">Exercise 7: Conditional statements and test Command&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
<section class="highlight-2">
	<h3>Conditional Statements</h3>
<ul>
	<li>Conditional statements are evaluated for true or false values.</li>
<li>This is done with the test, or its equivalent, the [] operators.</li>
<li>It the condition evaluates to true, a zero (TRUE) exit status is set,
<br>otherwise a non-zero (FALSE) exit status is set.</li>
<li>If there are no arguments a non-zero exit status is set. </li>
</ul>	
</section>
<h3>Tests for strings:</h3>
<table>
<tr><th>Test	</th><th>Meaning</th></tr>
<tr><td style="width:120px">-z string	</td><td>true if the string length is zero</td></tr>
<tr><td>-n string	</td><td>true if the string length is non-zero</td></tr>
<tr><td>string1 = string2	</td><td>true if string1 is identical to string2</td></tr>
<tr><td>string1 != string2	</td><td>true if string1 is non identical to string2</td></tr>
<tr><td>string 	</td><td>true if string is not NULL</td></tr>
</table>
	
<h3>Integer comparisons</h3>
<table>
<tr><th>Test	</th><th>Meaning</th><tr>
<tr><td style="width:120px">n1 -eq n2	</td><td>true if integers n1 and n2 are equal</td></tr>
<tr><td>n1 -ne n2	</td><td>true if integers n1 and n2 are not equal</td></tr>
<tr><td>n1 -gt n2	</td><td>true if integer n1 is greater than integer n2</td></tr>
<tr><td>n1 -ge n2	</td><td>true if integer n1 is greater than or equal to integer n2</td></tr>
<tr><td>n1 -lt n2	</td><td>true if integer n1 is less than integer n2</td></tr>
<tr><td>n1 -le n2	</td><td>true if integer n1 is less than or equal to integer n2</td></tr>
</table>	

<h3>Test for file attributes </h3>  
<p>For filenames, the options to test are given with the syntax:<br>
<code class="syntx">[ -option filename ]</code> </p>
<table>
<tr><th style="width:120px">Test	</th><th>Meaning</th><tr>
<tr><td>-r 	</td><td>true if it exists and is readable</td></tr>
<tr><td>-w	</td><td>true if it exists and is writable</td></tr>
<tr><td>-x 	</td><td>true if it exists and is executable</td></tr>
<tr><td>-f 	</td><td>true if it exists and is a regular file</td></tr> 
<tr><td>-d 	</td><td>true if it exists and is a directory</td></tr>
<tr><td>-h or -L 	</td><td>true if it exists and is a symbolic link</td></tr>
<tr><td>-c 	</td><td>true if it exists and is a character special file (i.e. the special device is accessed one character at a time)</td></tr>
<tr><td>-b 	</td><td>true if it exists and is a block special file (i.e. the device is accessed in blocks of data)</td></tr>
<tr><td>-p 	</td><td>true if it exists and is a named pipe (fifo)</td></tr>
<tr><td>-u 	</td><td>true if it exists and is setuid (i.e. has the set-user-id bit set, s or S in the third bit)</td></tr>
<tr><td>-g 	</td><td>true if it exists and is setgid (i.e. has the set-group-id bit set, s or S in the sixth bit)</td></tr>
<tr><td>-k 	</td><td>true if it exists and the sticky bit is set (a t in bit 9)</td></tr>
<tr><td>-s 	</td><td>true if it exists and is greater than zero in size</td></tr>
</table>

<section class="highlight-2">
	<h3>test Command</h3>
	<p>The test command makes preliminary checks of the Linux internal environment and other useful comparisons beyond those that the if command alone can perform.  You can place the test command inside your shell script or execute it directly fromt he command line. </p>
	<p>The test command uses operators expressed as options to perform the evaluation. It can be used to</p>
	<ul>
		<li>perform relational test with integers (equality, greater, less than,...)</li>
		<li>test strings</li>
		<li>determine if a file exists and what type of file it is</li>
		<li>perform Boolean tests</li>
	</ul>
		<p>The test command returns a value known as an exit status. An exit status is a numerical value that the command returns to the operating system when it finishes.  The value of the test command's exit status indicates the result of the test performed. If the exit status is 0 (zero), the test result is true. An exit status of 1 (one) indicates the test result is false.	</p>
	
	</section>
<pre class="brush: bash; first-line: 1; highlight: [0];" title="The exit status is normally detected in a script by the if statement or loop structure. You can view the last command's exit status by typing the command">
echo $?
</pre>
<pre class="brush: bash; first-line: 1; highlight: [1,6];" title="Try the following:">
number=20; value=10; name="Linux"
test $number -eq 20; echo $?
test $number -lt $value; echo $?
test $name = "Linux"; echo $?
test $name = "linux"; echo $?
touch testFile
test -x testFile; echo $?
test -r testFile; echo $?
test -d testFile; echo $?
test -s testFile; echo $?
test -w testFile; echo $?
test -f testFile; echo $?
</pre>

	<p>&nbsp;</p>
	<p>&nbsp;</p>
<h2 id="e08">Exercise 8: Using expr to evaluate&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
	<p>For each of the following commands, describe the output and explain what the command does. 
	If you are getting an error, debug and note the corrections.</p> 
	<pre class="brush: bash; highlight: [1];" title="">
expr 7 + 3
expr 7+3
expr 7 * 3
expr 7\*3
expr 7 \* 3
expr 7 \* \( 3 + 1 \)
expr 7 = 3
expr 7 \* \( 3 + 1 \) \| 222
expr 7 = 3 \| 222
expr length "Linux is a great operating system"
expr substr "Linux is a great operating system" 7 13
expr index "Linux is a great operating system" "x"</pre>
</p>	


	<p>&nbsp;</p>
	<p>&nbsp;</p>
<h2 id="e09">Exercise 9: Shell Variables - positional parameters (Command-line Arguments)&nbsp;&nbsp; <a href="#top"><img src="../images/uiTabsArrow.png" /></a>		</h2>
	<p> </p>
<table>
<tr><th>Variable	</th><th>Usage</th></tr>
<tr><td>$#	</td><td>Number of arguments on the command line (number of positional parameters)</td></tr>	
<tr><td>$-	</td><td>Options supplied to the shell</td></tr>	
<tr><td>$?	</td><td>Exit value of the last command executed</td></tr>	
<tr><td>$$	</td><td>Process number of the current process</td></tr>
<tr><td>$!	</td><td>Process number of the last command done in background</td></tr>	
<tr><td>$n	</td><td>Argument on the command line, where n is from 1 through 9, reading left to right, that is $1, $2, $3, $4, $5, $6, $7, $8, and $9, holding the value of the 1st, 2nd, 3rd, 4th, 5th, 6th, 7th, 8th, and 9th argument, respectively.</td></tr>
<tr><td>$0	</td><td>The name of the current shell or program (the first token)</td></tr>
<tr><td>$*	</td><td>All arguments on the command line (“$1 $2 … $9”)</td></tr>	
<tr><td>$@	</td><td>All arguments on the command line, each separately quoted (“$” “$2” … “$9”)</td></tr>	
</table>	
	
	<ol start="5"><strong>Try the following:</strong>
		<li>Enter at the bash command line (See manual pages for set and unset commands.). Note that the variable $1 holds the value A which is the first parameter in the set command, $2 holds the value B, and so on.
set A B C
	<pre class="brush: bash; highlight: [0];" title="">
set A B C
echo $1 $2 $3
</pre>		
		</li>	
		<li>Create a script called args.sh. Enter the code, save it, and make it executable. 

	<pre class="brush: bash; highlight: [0];" title="">
#!/bin/sh
echo “the first argument is $1”
echo “the second is $2”
echo the number off arguments is $#</pre>		
	Try running the script by providing a variety of arguments.

		</li>
	</ol>	

</p>


	
</section>
</body>
</html>
